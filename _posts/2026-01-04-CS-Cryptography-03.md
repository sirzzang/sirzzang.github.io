---
title:  "[Cryptography] 양방향 암호화 - 대칭키"
excerpt: "대칭키 암호화의 개념과 DES, 3DES, AES 알고리즘"
categories:
  - CS
toc: true
hidden: true
header:
  teaser: /assets/images/blog-Dev.jpg
tags:
  - Cryptography
  - 암호화
  - 보안
  - 대칭키
  - AES
  - DES
  - 블록암호
---

<br>

*[서종호(가시다)](https://www.linkedin.com/in/gasida99/)님의 On-Premise K8s Hands-on Study 자료를 기반으로 합니다.*


> 암호화 기초
> - (1) [암호학 기초 - 개념과 분류](/cs/CS-Cryptography-01/)
> - (2) [단방향 암호화 - 해시 함수](/cs/CS-Cryptography-02/)
> - **(3) 양방향 암호화 - 대칭키**
> - (4) 양방향 암호화 - 비대칭키

<br>

# 개요

양방향 암호화는 **복호화가 가능한** 암호화 방식이다. 그 중 **대칭키 암호화**는 암호화와 복호화에 **동일한 키**를 사용한다. 처리 속도가 빠르기 때문에 대용량 데이터 암호화에 주로 사용된다.

<br>

# 대칭키 암호화란?

대칭키 암호화(Symmetric Key Encryption)는 암호화와 복호화에 **같은 비밀 키**를 사용하는 방식이다.

> 공유 비밀키(Shared Secret Key), 관용(Conventional) 암호 방식이라고도 한다.

```
송신자(Alice)                    수신자(Bob)
    │                               │
    │  평문(Plaintext)              │
    ├───────────────────────────────┤
    │                               │
    │  암호화(Encrypt)               │
    │  키(Key) ──────── 공유 ────────┤
    │                               │
    │  암호문(Ciphertext)            │
    ├───────────────────────────────┤
    │                               │
    │                               │  복호화(Decrypt)
    │                               │  키(Key) ─────
    │                               │
    │                               │  평문(Plaintext)
    │                               │
```

```python
ciphertext = Encrypt(plaintext, key)
plaintext = Decrypt(ciphertext, key)  # 같은 키 사용
```

<br>

# 대칭키 암호화의 특징

## 장점: 빠른 처리 속도

대칭키 암호화는 **매우 빠르다**.

- 비트 단위 XOR, 치환(Substitution), 순열(Permutation) 같은 간단한 연산 사용
- CPU가 매우 빠르게 처리 가능
- 처리 속도: **수백 MB/s ~ 수 GB/s**

비대칭키 방식(수백 KB/s ~ 수십 MB/s)에 비해 100~1000배 이상 빠르다.

<br>

## 단점: 키 관리의 어려움

대칭키 방식의 가장 큰 문제는 **키 분배**이다.

- 송신자와 수신자가 **같은 키를 공유**해야 함
- 인터넷을 통해 키를 전송하면 탈취될 위험이 있음
- N명이 서로 통신하려면 **N(N-1)/2개의 키**가 필요

이 문제를 해결하기 위해 비대칭키 암호화와 함께 사용하는 경우가 많다.

<br>

# 블록 암호화 vs 스트림 암호화

대칭키 암호화는 **블록 암호화**와 **스트림 암호화**로 구분된다.

**블록 암호화 (Block Cipher)**
- 고정 크기의 블록(64비트 또는 128비트 등) 단위로 데이터 처리
- 대표 알고리즘: DES, 3DES, AES, Blowfish
- 용도: 파일이나 디스크 암호화에 적합

**스트림 암호화 (Stream Cipher)**
- 비트 또는 바이트 단위로 연속적으로 데이터 처리
- 대표 알고리즘: RC4, ChaCha20
- 용도: 실시간 통신이나 영상 스트리밍에 적합

이 글에서는 주로 **블록 암호화**를 다룬다.

<br>

# 블록 암호화 알고리즘

## DES (Data Encryption Standard)

DES는 1977년 미국 표준으로 채택된 대칭키 블록 암호 알고리즘이다.

```
평문 (Plaintext)
    │
    ├─ 64비트 블록으로 분할
    │
    ├─ [블록1] [블록2] [블록3] ...
    │
    ├─ 각 블록에 56비트 키로 암호화
    │
    └─ [암호블록1] [암호블록2] [암호블록3] ...
```

- 평문을 **64비트 블록**으로 분할
- 각 블록에 대해 **56비트 키**로 암호화 (실제 입력은 64비트이지만 8비트는 패리티 비트)
- 64비트 암호문 블록 생성

<br>

### 패딩 (Padding)

평문이 64비트로 정확히 나누어지지 않을 경우, **패딩**을 추가하여 블록 크기를 맞춘다.

```
원본: "HELLO" (40비트)
패딩 후: "HELLO" + 패딩(24비트) = 64비트
```

가장 널리 사용되는 패딩 방식은 PKCS#7로, 부족한 바이트 수만큼 해당 값으로 채운다. 예를 들어 5바이트가 부족하면 `0x05 0x05 0x05 0x05 0x05`를 추가한다.

<br>

### DES 암호화 예시

`eraser`를 DES로 암호화하는 예시:

**암호화 과정:**
```
평문: "eraser"
    │
    ├─ 패딩 추가 (64비트 블록 크기로 맞춤)
    │
    ├─ DES 알고리즘 적용 (56비트 키 사용)
    │
    └─ 암호문 생성
```

**암호화 결과:**
```
eraser → 53616c7465645f5f471e00ca535f0f17da1ab3550175aa90
```

<br>

### DES 복호화 예시

암호문을 다시 평문으로 복호화:

**복호화 과정:**
```
암호문: 53616c7465645f5f471e00ca535f0f17da1ab3550175aa90
    │
    ├─ DES 복호화 알고리즘 적용 (같은 56비트 키 사용)
    │
    ├─ 패딩 제거
    │
    └─ 평문 복원
```

**복호화 결과:**
```
53616c7465645f5f471e00ca535f0f17da1ab3550175aa90 → eraser
```

<br>

### DES의 한계

- 56비트 키는 현대 컴퓨팅 환경에서 **쉽게 깨질 수 있음**
- 1999년 EFF(Electronic Frontier Foundation)가 22시간 만에 DES 암호 해독
- 전수 조사(Brute Force) 공격에 취약: 2^56 = 약 7200만 개의 키만 시도하면 됨
- **보안 용도로 더 이상 사용하면 안 됨**

<br>

## 3DES (Triple DES)

DES의 보안 취약점을 보완하기 위해 **DES를 3번 반복** 적용하는 방식이다.

```
암호화: E(D(E(평문, K1), K2), K3)
복호화: D(E(D(암호문, K3), K2), K1)
```

이를 EDE (Encrypt-Decrypt-Encrypt) 모드라고 하며, 다음과 같은 특징이 있다:

- 두 종류(또는 세 종류)의 56비트 키 사용
- 효과적인 키 길이: 112비트 또는 168비트
- DES보다 안전하지만, **3배 느림**
- 현재는 AES로 대체되는 추세

<br>

## AES (Advanced Encryption Standard)

AES는 2001년 미국 표준으로 채택된 현대 대칭키 블록 암호 알고리즘이다. **현재 가장 널리 사용**되는 대칭키 알고리즘이다.

### 특징

- 블록 크기: **128비트**
- 키 길이: **128, 192, 256비트** 선택 가능
- DES보다 빠르고 안전함
- 하드웨어 가속 지원 (AES-NI)

<br>

### 키 길이에 따른 명칭

AES는 키 길이에 따라 세 가지 변형이 있다:

- **AES-128**: 128비트 키 사용, 10라운드 암호화
- **AES-192**: 192비트 키 사용, 12라운드 암호화
- **AES-256**: 256비트 키 사용, 14라운드 암호화

<br>

각각 다음의 특징을 가진다:
- 키가 길수록 안전하지만 처리 시간이 조금 더 걸림
- 일반적인 용도에서는 AES-128도 충분히 안전
- 높은 보안이 필요한 경우 AES-256 사용

<br>

### AES 사용 예시 (Python)

```python
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
from Crypto.Util.Padding import pad, unpad

# 256비트(32바이트) 키 생성
key = get_random_bytes(32)

# 암호화
cipher = AES.new(key, AES.MODE_CBC)
plaintext = b"Hello, World!"
ciphertext = cipher.encrypt(pad(plaintext, AES.block_size))
iv = cipher.iv

# 복호화
cipher_dec = AES.new(key, AES.MODE_CBC, iv)
decrypted = unpad(cipher_dec.decrypt(ciphertext), AES.block_size)
print(decrypted)  # b'Hello, World!'
```

<br>

# 대칭키의 한계와 해결책

## 키 분배 문제

대칭키 방식의 근본적인 문제는, 인터넷을 통해 **비밀 키를 어떻게 안전하게 공유**할 것인가이다.

```
송신자(Alice)          중간자(Eve)          수신자(Bob)
    │                      │                    │
    │  비밀키 전송?           │                    │
    ├──────────────────────┼────────────────────┤
    │                      │                    │
    │                  키 탈취 가능!               │
    │                      │                    │
    └──────────────────────┴────────────────────┘
```

키를 평문으로 전송하면 중간자가 탈취할 수 있다. 이 문제를 해결하기 위해 **하이브리드 암호화(Hybrid Encryption)** 방식이 개발되었다.

<br>

## 하이브리드 암호화 (Hybrid Encryption)

하이브리드 암호화는 **비대칭키 암호화의 안전한 키 교환**과 **대칭키 암호화의 빠른 처리 속도**를 결합한 방식이다.

### 기본 원리

1. **비대칭키(공개키)**: 대칭키를 안전하게 전송하는 데 사용
2. **대칭키**: 실제 데이터 암호화에 사용

이 방식은 HTTPS, TLS, SSH 등 현대 인터넷 보안의 핵심이다.

<br>

# 키 분배 알고리즘

키 분배 알고리즘으로 다음과 같은 것이 있다.
1. 오프라인 전달
2. Diffie-Hellman 키 교환 알고리즘
3. RSA 키 분배
4. 키 분배 센터(KDC)

## RSA 키 분배

RSA는 가장 널리 사용되는 공개키 암호 알고리즘으로, 대칭키를 안전하게 전송하는 데 사용된다.

> RSA 알고리즘에 대한 자세한 내용은 [양방향 암호화 - 비대칭키](/cs/CS-Cryptography-04/)를 참고하자.

<br>

### RSA 키 분배 과정

```
Alice (송신자)                    Bob (수신자)
    │                                 │
    │  1. Bob의 공개키 요청            │
    │  ──────────────────────────────>│
    │                                 │
    │                                 │  2. 공개키 전송
    │  <──────────────────────────────│  (Public Key: e, n)
    │                                 │
    │  3. 대칭키 생성                 │
    │     session_key = random()      │
    │                                 │
    │  4. RSA로 대칭키 암호화         │
    │     encrypted_key =             │
    │       RSA_encrypt(              │
    │         session_key,            │
    │         Bob_public_key          │
    │       )                         │
    │                                 │
    │  5. 암호화된 키 전송             │
    │  ──────────────────────────────>│
    │                                 │
    │                                 │  6. RSA로 대칭키 복호화
    │                                 │     session_key =
    │                                 │       RSA_decrypt(
    │                                 │         encrypted_key,
    │                                 │         Bob_private_key
    │                                 │       )
    │                                 │
    │  7. 대칭키로 데이터 암호화       │
    │     ciphertext =                │
    │       AES_encrypt(              │
    │         data,                   │
    │         session_key             │
    │       )                         │
    │                                 │
    │  8. 암호화된 데이터 전송        │
    │  ──────────────────────────────>│
    │                                 │
    │                                 │  9. 대칭키로 데이터 복호화
    │                                 │     data =
    │                                 │       AES_decrypt(
    │                                 │         ciphertext,
    │                                 │         session_key
    │                                 │       )
```

### 상세 설명

**1-2단계: 키 생성 및 공개키 전송**
- Bob이 RSA 키 쌍 생성: 공개키 (e, n)과 개인키 (d, n)
- Bob이 공개키를 Alice에게 전송
- 중간자가 공개키를 탈취해도 문제없음

**3-4단계: 대칭키 생성 및 암호화**
- Alice가 랜덤한 대칭키(세션키) 생성 (예: AES-256용 32바이트)
- Alice가 생성한 대칭키를 Bob의 공개키로 RSA 암호화
- RSA는 작은 데이터만 효율적으로 암호화 가능

**5-6단계: 키 전송 및 복호화**
- 암호화된 대칭키를 Bob에게 전송
- 중간자가 탈취해도 Bob의 개인키 없이는 복호화 불가능
- Bob이 자신의 개인키로 대칭키 복호화

**7-9단계: 데이터 암호화 및 전송**
- Alice와 Bob 모두 같은 대칭키를 공유
- 이후 모든 데이터는 빠른 대칭키(AES 등)로 암호화하여 전송

### RSA 키 분배의 장단점

**장점:**
1. **안전한 키 교환**: 공개 채널을 통해서도 안전하게 키 교환 가능
2. **확장성**: N명이 통신하려면 N개의 공개키만 필요 (대칭키는 N(N-1)/2개 필요)
3. **효율성**: 대용량 데이터는 빠른 대칭키로 암호화, 작은 키만 느린 비대칭키로 암호화

**단점:**
1. **성능**: RSA 암호화/복호화는 대칭키보다 느림 (100~1000배)
2. **키 크기 제한**: RSA는 암호화할 수 있는 데이터 크기가 제한적
   - 2048비트 RSA 키는 최대 245바이트 정도만 암호화 가능 (PKCS#1 v1.5 패딩 사용 시)
   - 따라서 대칭키(보통 16~32바이트) 같은 작은 데이터에만 사용

이러한 한계 때문에 **하이브리드 방식**이 필수적이다.

<br>

## 4. 키 분배 센터 (KDC)

신뢰할 수 있는 제3자(Key Distribution Center)가 키를 분배하는 방식이다.

### Kerberos 프로토콜

가장 유명한 KDC 기반 인증 프로토콜로, 아래와 같은 특징을 가진다:
- 중앙 집중식 키 관리
- 티켓 기반 인증 시스템
- 주로 기업 내부 네트워크에서 사용 (Active Directory 등)

<br>

**장점:**
- 중앙에서 키 관리가 용이
- 사용자 관리 편리

**단점:**
- 단일 실패점(Single Point of Failure)
- KDC가 침해되면 전체 시스템 위험

<br>

# 현대 시스템에서의 활용

대부분의 현대 시스템(HTTPS, TLS, SSH 등)은 **하이브리드 방식**을 사용한다.

## TLS 핸드셰이크

TLS 1.2의 RSA 키 교환 방식을 예시로 들면:

```
클라이언트                    서버
    │                          │
    │  1. ClientHello          │
    │  ──────────────────────> │
    │                          │
    │                          │  2. ServerHello
    │                          │     + 서버 인증서
    │                          │     + 공개키
    │  <────────────────────── │
    │                          │
    │  3. 인증서 검증           │
    │     (CA 서명 확인)        │
    │                          │
    │  4. Pre-Master Secret    │
    │     생성 (세션키 재료)    │
    │                          │
    │  5. 서버 공개키로         │
    │     암호화하여 전송       │
    │  ──────────────────────> │
    │                          │
    │                          │  6. 개인키로 복호화
    │                          │
    │  7. 양쪽에서 Master Secret 생성
    │     (동일한 세션키 도출)  │
    │  <──────────────────────>│
    │                          │
    │  8. 이후 모든 통신은     │
    │     세션키(대칭키)로      │
    │     암호화                │
    │  <──────────────────────>│
```

**TLS 1.3의 개선:**
- Perfect Forward Secrecy(PFS)를 위해 Diffie-Hellman 기반 키 교환 필수화
- RSA 키 교환 방식 제거
- 핸드셰이크 단축으로 성능 개선

이 방식으로 **안전한 키 교환**과 **빠른 데이터 암호화**를 모두 달성한다.

<br>

# 정리

대칭키 암호화의 핵심 개념을 정리하면 다음과 같다.

**대칭키 암호화의 기본:**
- 암복호화에 같은 키를 사용하는 방식
- 장점은 빠른 처리 속도(수백 MB/s ~ 수 GB/s)
- 단점은 키 분배의 어려움

**블록 암호 알고리즘:**
- DES: 56비트 키 사용, 현재 취약하여 사용 금지
- 3DES: DES를 3회 적용하는 방식으로 레거시 시스템에서만 제한적 사용
- AES: 128/192/256비트 키 사용, 현재 표준으로 가장 널리 사용됨

**블록 암호 운용 모드:**
- ECB: 보안 취약으로 사용 금지
- CBC: 가장 널리 사용되는 모드, IV 필수
- GCM: 암호화와 인증을 동시에 제공, HTTPS에서 사용

**키 분배 문제와 해결책:**
- 하이브리드 암호화: 비대칭키의 안전한 키 교환 + 대칭키의 빠른 처리 속도 결합
- Diffie-Hellman: 공개 채널에서 안전하게 공유 비밀 생성, 이산 로그 문제에 기반
- RSA 키 분배: 비대칭키로 대칭키를 암호화하여 전송, 현대 시스템에서 가장 널리 사용
- Kerberos: 중앙 집중식 키 분배 시스템, 기업 내부 네트워크에서 사용

**실무 적용:**
- TLS/HTTPS: RSA 또는 Diffie-Hellman으로 세션키 교환 후 AES로 데이터 암호화
- TLS 1.3: Perfect Forward Secrecy를 위해 Diffie-Hellman 기반 키 교환 필수화

<br>
